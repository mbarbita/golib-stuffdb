// tier n:
db[n]:
// Tn data map:
    map[ [data map id]: value;... ]
// Tn ref map:
    map[ list id: map[id: taget(tier,list id);... ];... ]

even tiers = data
odd tiers = data and refs
so target(tier, list id) knows what is there ([list id] refers to value map or
ref map)
db[n] contains only data map on even tiers and both maps on odd tiers

// tier n+1
db[n+1]:
// Tn+1 data map:
    map[ [data map id]: value;... ]
// Tn+1 ref map:
    map[ list id: map[id: taget(tier,list id);... ];... ]

// tier n+2
// Tn+2 data map:
    map[ [data map id]: value;... ]
// Tn+2 ref map:
    map[ list id: map[id: taget(tier,list id);... ];... ]

...

// n=0
// T0
// T0 data map:
map[ 1: dude A;
     2: dude B;
     3: dude C; ]

// T0 ref map:
none: n=0

// T1
// T1 data map:
map[ 1: dudes;
     2: friends;]

// T1 ref map:
map[ 1: map[ 1: 0,1;
             2: 0,2;
             3: 0,3;];
     2: map[ 1: 0,2;
             2: 0,3;];]

Target:
struct {
tier,
map id,
selector []string
}

selector
if len(selector) = 0: data = none
if len(selector) = 1 {
  if selector contains ":" { data = range[map[min]:map[max]]
    } else {
     key = val(selector), data = map[key] }
  }

if len(selector) > 1 {
  if selector contain ":" {
    data = enum of ranges
    } else {
    enum data = [map[sel1], map[sel2], map[sel3] ... ]
    }
  }
